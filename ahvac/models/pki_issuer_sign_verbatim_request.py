# coding: utf-8

"""
    HashiCorp Vault API

    HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.

    The version of the OpenAPI document: 1.15.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class PkiIssuerSignVerbatimRequest(BaseModel):
    """
    PkiIssuerSignVerbatimRequest
    """ # noqa: E501
    alt_names: Optional[StrictStr] = Field(default=None, description="The requested Subject Alternative Names, if any, in a comma-delimited list. If email protection is enabled for the role, this may contain email addresses.")
    common_name: Optional[StrictStr] = Field(default=None, description="The requested common name; if you want more than one, specify the alternative names in the alt_names map. If email protection is enabled in the role, this may be an email address.")
    csr: Optional[StrictStr] = Field(default='', description="PEM-format CSR to be signed. Values will be taken verbatim from the CSR, except for basic constraints.")
    exclude_cn_from_sans: Optional[StrictBool] = Field(default=False, description="If true, the Common Name will not be included in DNS or Email Subject Alternate Names. Defaults to false (CN is included).")
    ext_key_usage: Optional[List[StrictStr]] = Field(default=None, description="A comma-separated string or list of extended key usages. Valid values can be found at https://golang.org/pkg/crypto/x509/#ExtKeyUsage -- simply drop the \"ExtKeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.")
    ext_key_usage_oids: Optional[List[StrictStr]] = Field(default=None, description="A comma-separated string or list of extended key usage oids.")
    format: Optional[StrictStr] = Field(default='pem', description="Format for returned data. Can be \"pem\", \"der\", or \"pem_bundle\". If \"pem_bundle\", any private key and issuing cert will be appended to the certificate pem. If \"der\", the value will be base64 encoded. Defaults to \"pem\".")
    ip_sans: Optional[List[StrictStr]] = Field(default=None, description="The requested IP SANs, if any, in a comma-delimited list")
    key_usage: Optional[List[StrictStr]] = Field(default=None, description="A comma-separated string or list of key usages (not extended key usages). Valid values can be found at https://golang.org/pkg/crypto/x509/#KeyUsage -- simply drop the \"KeyUsage\" part of the name. To remove all key usages from being set, set this value to an empty list.")
    not_after: Optional[StrictStr] = Field(default=None, description="Set the not after field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ")
    other_sans: Optional[List[StrictStr]] = Field(default=None, description="Requested other SANs, in an array with the format <oid>;UTF8:<utf8 string value> for each entry.")
    private_key_format: Optional[StrictStr] = Field(default='der', description="Format for the returned private key. Generally the default will be controlled by the \"format\" parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to \"pkcs8\" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Defaults to \"der\".")
    remove_roots_from_chain: Optional[StrictBool] = Field(default=False, description="Whether or not to remove self-signed CA certificates in the output of the ca_chain field.")
    serial_number: Optional[StrictStr] = Field(default=None, description="The Subject's requested serial number, if any. See RFC 4519 Section 2.31 'serialNumber' for a description of this field. If you want more than one, specify alternative names in the alt_names map using OID 2.5.4.5. This has no impact on the final certificate's Serial Number field.")
    signature_bits: Optional[StrictInt] = Field(default=0, description="The number of bits to use in the signature algorithm; accepts 256 for SHA-2-256, 384 for SHA-2-384, and 512 for SHA-2-512. Defaults to 0 to automatically detect based on key length (SHA-2-256 for RSA keys, and matching the curve size for NIST P-Curves).")
    ttl: Optional[StrictStr] = Field(default=None, description="The requested Time To Live for the certificate; sets the expiration date. If not specified the role default, backend default, or system default TTL is used, in that order. Cannot be larger than the role max TTL.")
    uri_sans: Optional[List[StrictStr]] = Field(default=None, description="The requested URI SANs, if any, in a comma-delimited list.")
    use_pss: Optional[StrictBool] = Field(default=False, description="Whether or not to use PSS signatures when using a RSA key-type issuer. Defaults to false.")
    user_ids: Optional[List[StrictStr]] = Field(default=None, description="The requested user_ids value to place in the subject, if any, in a comma-delimited list. Restricted by allowed_user_ids. Any values are added with OID 0.9.2342.19200300.100.1.1.")
    __properties: ClassVar[List[str]] = ["alt_names", "common_name", "csr", "exclude_cn_from_sans", "ext_key_usage", "ext_key_usage_oids", "format", "ip_sans", "key_usage", "not_after", "other_sans", "private_key_format", "remove_roots_from_chain", "serial_number", "signature_bits", "ttl", "uri_sans", "use_pss", "user_ids"]

    @field_validator('format')
    def format_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['pem', 'der', 'pem_bundle']):
            raise ValueError("must be one of enum values ('pem', 'der', 'pem_bundle')")
        return value

    @field_validator('private_key_format')
    def private_key_format_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'der', 'pem', 'pkcs8']):
            raise ValueError("must be one of enum values ('', 'der', 'pem', 'pkcs8')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PkiIssuerSignVerbatimRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PkiIssuerSignVerbatimRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "alt_names": obj.get("alt_names"),
            "common_name": obj.get("common_name"),
            "csr": obj.get("csr") if obj.get("csr") is not None else '',
            "exclude_cn_from_sans": obj.get("exclude_cn_from_sans") if obj.get("exclude_cn_from_sans") is not None else False,
            "ext_key_usage": obj.get("ext_key_usage"),
            "ext_key_usage_oids": obj.get("ext_key_usage_oids"),
            "format": obj.get("format") if obj.get("format") is not None else 'pem',
            "ip_sans": obj.get("ip_sans"),
            "key_usage": obj.get("key_usage"),
            "not_after": obj.get("not_after"),
            "other_sans": obj.get("other_sans"),
            "private_key_format": obj.get("private_key_format") if obj.get("private_key_format") is not None else 'der',
            "remove_roots_from_chain": obj.get("remove_roots_from_chain") if obj.get("remove_roots_from_chain") is not None else False,
            "serial_number": obj.get("serial_number"),
            "signature_bits": obj.get("signature_bits") if obj.get("signature_bits") is not None else 0,
            "ttl": obj.get("ttl"),
            "uri_sans": obj.get("uri_sans"),
            "use_pss": obj.get("use_pss") if obj.get("use_pss") is not None else False,
            "user_ids": obj.get("user_ids")
        })
        return _obj


