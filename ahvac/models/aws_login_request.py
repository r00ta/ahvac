# coding: utf-8

"""
    HashiCorp Vault API

    HTTP API that gives you full access to Vault. All API routes are prefixed with `/v1/`.

    The version of the OpenAPI document: 1.15.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class AwsLoginRequest(BaseModel):
    """
    AwsLoginRequest
    """ # noqa: E501
    iam_http_request_method: Optional[StrictStr] = Field(default=None, description="HTTP method to use for the AWS request when auth_type is iam. This must match what has been signed in the presigned request.")
    iam_request_body: Optional[StrictStr] = Field(default=None, description="Base64-encoded request body when auth_type is iam. This must match the request body included in the signature.")
    iam_request_headers: Optional[StrictStr] = Field(default=None, description="Key/value pairs of headers for use in the sts:GetCallerIdentity HTTP requests headers when auth_type is iam. Can be either a Base64-encoded, JSON-serialized string, or a JSON object of key/value pairs. This must at a minimum include the headers over which AWS has included a signature.")
    iam_request_url: Optional[StrictStr] = Field(default=None, description="Base64-encoded full URL against which to make the AWS request when using iam auth_type.")
    identity: Optional[StrictStr] = Field(default=None, description="Base64 encoded EC2 instance identity document. This needs to be supplied along with the 'signature' parameter. If using 'curl' for fetching the identity document, consider using the option '-w 0' while piping the output to 'base64' binary.")
    nonce: Optional[StrictStr] = Field(default=None, description="The nonce to be used for subsequent login requests when auth_type is ec2. If this parameter is not specified at all and if reauthentication is allowed, then the backend will generate a random nonce, attaches it to the instance's identity access list entry and returns the nonce back as part of auth metadata. This value should be used with further login requests, to establish client authenticity. Clients can choose to set a custom nonce if preferred, in which case, it is recommended that clients provide a strong nonce. If a nonce is provided but with an empty value, it indicates intent to disable reauthentication. Note that, when 'disallow_reauthentication' option is enabled on either the role or the role tag, the 'nonce' holds no significance.")
    pkcs7: Optional[StrictStr] = Field(default=None, description="PKCS7 signature of the identity document when using an auth_type of ec2.")
    role: Optional[StrictStr] = Field(default=None, description="Name of the role against which the login is being attempted. If 'role' is not specified, then the login endpoint looks for a role bearing the name of the AMI ID of the EC2 instance that is trying to login. If a matching role is not found, login fails.")
    signature: Optional[StrictStr] = Field(default=None, description="Base64 encoded SHA256 RSA signature of the instance identity document. This needs to be supplied along with 'identity' parameter.")
    __properties: ClassVar[List[str]] = ["iam_http_request_method", "iam_request_body", "iam_request_headers", "iam_request_url", "identity", "nonce", "pkcs7", "role", "signature"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AwsLoginRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AwsLoginRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "iam_http_request_method": obj.get("iam_http_request_method"),
            "iam_request_body": obj.get("iam_request_body"),
            "iam_request_headers": obj.get("iam_request_headers"),
            "iam_request_url": obj.get("iam_request_url"),
            "identity": obj.get("identity"),
            "nonce": obj.get("nonce"),
            "pkcs7": obj.get("pkcs7"),
            "role": obj.get("role"),
            "signature": obj.get("signature")
        })
        return _obj


